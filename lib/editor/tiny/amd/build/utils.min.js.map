{"version":3,"file":"utils.min.js","sources":["../src/utils.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nimport {renderForPromise} from 'core/templates';\nimport {getFilePicker} from './options';\n\n/**\n * Get the image path for the specified image.\n *\n * @param {string} identifier The name of the image\n * @param {string} component The component name\n * @return {string} The image URL path\n */\nexport const getImagePath = (identifier, component = 'editor_tiny') => Promise.resolve(M.util.image_url(identifier, component));\n\nexport const getButtonImage = async(identifier, component = 'editor_tiny') => renderForPromise('editor_tiny/toolbar_button', {\n    image: await getImagePath(identifier, component),\n});\n\n/**\n * Helper to display a filepicker and return a Promise.\n *\n * The Promise will resolve when a file is selected, or reject if the file type is not found.\n *\n * @param {TinyMCE} editor\n * @param {string} filetype\n * @returns {Promise<object>} The file object returned by the filepicker\n */\nexport const displayFilepicker = (editor, filetype) => new Promise((resolve, reject) => {\n    const configuration = getFilePicker(editor, filetype);\n    if (configuration) {\n        const options = {\n            ...configuration,\n            formcallback: resolve,\n        };\n        M.core_filepicker.show(Y, options);\n        return;\n    }\n    reject(`Unknown filetype ${filetype}`);\n});\n\n/**\n * Given a TinyMCE Toolbar configuration, add the specified button to the named section.\n *\n * @param {object} toolbar\n * @param {string} section\n * @param {string} button\n * @returns {object} The toolbar configuration\n */\nexport const addToolbarButton = (toolbar, section, button) => {\n    if (!toolbar) {\n        return [{\n            name: section,\n            items: [button],\n        }];\n    }\n\n    const mutatedToolbar = JSON.parse(JSON.stringify(toolbar));\n    return mutatedToolbar.map((item) => {\n        if (item.name === section) {\n            item.items.push(button);\n        }\n\n        return item;\n    });\n};\n\n/**\n * Given a TinyMCE Menubar configuration, add the specified button to the named section.\n *\n * @param {object} menubar\n * @param {string} section\n * @param {string} menuitem\n * @returns {object}\n */\nexport const addMenubarItem = (menubar, section, menuitem) => {\n    if (!menubar) {\n        const emptyMenubar = {};\n        emptyMenubar[section] = {\n            title: section,\n            items: menuitem,\n        };\n    }\n\n    const mutatedMenubar = JSON.parse(JSON.stringify(menubar));\n    Array.from(Object.entries(mutatedMenubar)).forEach(([name, menu]) => {\n        if (name === section) {\n            menu.items = `${menu.items} ${menuitem}`;\n        }\n    });\n\n    return mutatedMenubar;\n};\n\n/**\n * Given a TinyMCE contextmenu configuration, add the specified button to the end.\n *\n * @param {string} contextmenu\n * @param {string} menuitem\n * @returns {string}\n */\nexport const addContextmenuItem = (contextmenu, menuitem) => {\n    const contextmenuItems = (contextmenu ?? '').split(' ');\n\n    return contextmenuItems\n        .concat(menuitem)\n        .filter((item) => item !== '')\n        .join(' ');\n};\n"],"names":["getImagePath","identifier","component","Promise","resolve","M","util","image_url","async","image","editor","filetype","reject","configuration","options","formcallback","core_filepicker","show","Y","toolbar","section","button","name","items","JSON","parse","stringify","map","item","push","menubar","menuitem","title","mutatedMenubar","Array","from","Object","entries","forEach","_ref","menu","contextmenu","split","concat","filter","join"],"mappings":"wUAyBaA,aAAe,SAACC,gBAAYC,iEAAY,qBAAkBC,QAAQC,QAAQC,EAAEC,KAAKC,UAAUN,WAAYC,wEAEtFM,eAAMP,gBAAYC,iEAAY,qBAAkB,+BAAiB,6BAA8B,CACzHO,YAAaT,aAAaC,WAAYC,yCAYT,CAACQ,OAAQC,WAAa,IAAIR,SAAQ,CAACC,QAASQ,gBACnEC,eAAgB,0BAAcH,OAAQC,aACxCE,qBACMC,QAAU,IACTD,cACHE,aAAcX,SAElBC,EAAEW,gBAAgBC,KAAKC,EAAGJ,cAG9BF,kCAA2BD,wCAWC,CAACQ,QAASC,QAASC,cAC1CF,cACM,CAAC,CACJG,KAAMF,QACNG,MAAO,CAACF,iBAIOG,KAAKC,MAAMD,KAAKE,UAAUP,UAC3BQ,KAAKC,OACnBA,KAAKN,OAASF,SACdQ,KAAKL,MAAMM,KAAKR,QAGbO,iCAYe,CAACE,QAASV,QAASW,gBACxCD,QAAS,EACW,IACRV,SAAW,CACpBY,MAAOZ,QACPG,MAAOQ,gBAITE,eAAiBT,KAAKC,MAAMD,KAAKE,UAAUI,iBACjDI,MAAMC,KAAKC,OAAOC,QAAQJ,iBAAiBK,SAAQC,WAAEjB,KAAMkB,WACnDlB,OAASF,UACToB,KAAKjB,gBAAWiB,KAAKjB,kBAASQ,cAI/BE,4CAUuB,CAACQ,YAAaV,YAClBU,MAAAA,YAAAA,YAAe,IAAIC,MAAM,KAG9CC,OAAOZ,UACPa,QAAQhB,MAAkB,KAATA,OACjBiB,KAAK"}